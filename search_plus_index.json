{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 学习element-ui源码并搭建自己的业务UI库 steam-game-ui powered by Gitbook该文件修订时间： 2019-09-12 00:10:40 "},"structures/工作流.html":{"url":"structures/工作流.html","title":"工作流","keywords":"","body":"基于vue-cli3 steam-game-ui基于vue-cli3搭建的脚手架来开发。我们需要把组件库通过lib模式打包 npm run build:file && vue-cli-service build --target lib --name steam-game-ui --dest lib packages/index.js 还需要在vue.config.js里面merge别名配置和babel转义 config.resolve.alias .set('@', path.resolve('examples')) .set('src', path.resolve('src')) .set('packages', path.resolve('packages')) .set('examples', path.resolve('examples')); config.module .rule('js') .include.add(/packages/) .end() .include.add(/examples/) .end() .use('babel') .loader('babel-loader') .tap(options => { return options; }) .end(); 开发流程 开发新组件命令 npm run new 组件名 [组件中文名] npm run new button 按钮 npm run serve 发布步骤👇 npm run test npm version patch npm run lib git add . git commit --amend npm publish 代码规范 .editorconfig配置👇 [*.{js,jsx,ts,tsx,vue}] indent_style = space indent_size = 2 trim_trailing_whitespace = true insert_final_newline = true .prettierrc配置👇 { \"trailingComma\": \"none\", \"singleQuote\": true, \"semi\": true, \"tabWidth\": 2, \"semicolons\": true, \"bracketSpacing\": true } .eslintrc配置👇 module.exports = { root: true, parserOptions: { parser: 'babel-eslint' }, env: { browser: true }, extends: [ 'plugin:vue/essential', '@vue/standard' ], rules: { 'prefer-promise-reject-errors': 0, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'arrow-parens': 0, 'generator-star-spacing': 0, 'space-before-function-paren': 0, 'semi': ['error', 'always'], 'indent': 0, 'no-fallthrough': 0, 'eqeqeq': 0, 'one-var': 0, 'no-extra-boolean-cast': 0, 'camelcase': 0, 'no-mixed-operators': 0, 'eol-last': 0 } } 自动部署 官网直接部署在github pages上，通过travis来做跑测试和自动化部署 language: node_js env: global: - GH_REF: github.com/meishaFE/steam-game-ui.git cache: directories: - ~/.npm - node_modules node_js: - '9' install: - npm install script: - npm run test - npm run build after_script: - cd ./dist - git init - git add . - git commit -m \"Travis CI Auto Builder\" - git push --force --quiet \"https://${TOKEN_AARON}@${GH_REF}\" master:gh-pages powered by Gitbook该文件修订时间： 2019-09-12 00:10:40 "},"structures/生成文档和示例.html":{"url":"structures/生成文档和示例.html","title":"生成文档和示例.md","keywords":"","body":"需求背景 组件库要被人家使用，所以一定需要有使用demo和API解析。这两个工作是可以合并在同一份markdown文件里面的，所以我们需要提取markdown里面的代码片段，然后渲染成demo就可以，这块我们手写一个loader来处理，具体的逻辑在build/markdown-loader.js里面。 添加loader 我们要转换.md文件为HTML标签，同时提取里面的代码块，然后对代码块做一些自定义处理，最后返回vue单文件组件模板，传递给vue-loader去解析。多loader是串联链式调用的，按逆序执行，所以我们在vue.config.js里面添加下面对.md的处理👇 config.module .rule('md') .test(/\\.md/) .use('vue-loader') .loader('vue-loader') .options({ compilerOptions: { preserveWhitespace: false } }) .end() .use('markdown-loader') .loader( require('path').resolve(__dirname, './build/markdown-loader.js') ) .end(); loader逻辑 markdown-it这个库可以把Markdown文档转换成HTML标签，配合markdown-it-container这个插件可以提取特定标签内内容。在steam-game-ui里面我们定义:::demo 代码块 :::里面的代码块需要被渲染成Vue组件。 const md = require('markdown-it')(); const VueTemplateComplier = require('vue-template-compiler'); const { parse, compileTemplate } = require('@vue/component-compiler-utils'); let componentCodeList = []; md.use(require('markdown-it-container'), 'demo', { // 验证代码块为【:::demo :::】才进行渲染 validate: function(params) { return params.trim().match(/^demo\\s+(.*)$/); }, // 代码块渲染 render: function (tokens, idx) { const token = tokens[index]; const tokenInfo = token.info.trim().match(/^demo\\s*(.*)$/); if (token.nesting === 1) { // 开始标签 // 获取demo的第一行代码描述，即::: demo xxx 中的xxx const desc = tokenInfo && tokenInfo.length > 1 ? tokenInfo[1] : ''; // 获取demo中需要渲染的内容 const nextIndex = tokens[index + 1]; const content = nextIndex.type === 'fence' ? nextIndex.content : ''; // 将content解析为vue组件基本属性对象 let { template, script, styles } = parse({ source: content, compiler: VueTemplateComplier, needMap: false }); // 将content的内容分别提炼出来并转码，给codepen作为提交表单使用 let rawCodepen = { html: (template && template.content || '').replace(/^(\\/|\\n)*/g, ''), js: (script && script.content || '').replace(/^(\\/|\\n)*/g, ''), css: (styles && styles.content || '').replace(/^(\\/|\\n)*/g, '') }; let codepen = markdownIt.utils.escapeHtml(JSON.stringify(rawCodepen)); // 将template转为render函数 const { code } = compileTemplate({ source: template.content, compiler: VueTemplateComplier }); styleCodeList = styleCodeList.concat(styles); // 获取script的代码 script = script ? script.content : ''; if (script) { script = script.replace( /export\\s+default/, 'const exportJavaScript =' ); } else { script = 'const exportJavaScript = {} ;'; } // 将代码解析成vue组件存储，然后在渲染html中引用该组件 const name = `st-demo-${componentCodeList.length}`; componentCodeList.push(`\"${name}\":(function () { ${code} ${script} return { ...exportJavaScript, render, staticRenderFns } })()`); // 将需要渲染的示例用code-block组件包裹替换插槽显示示例效果 return ` ${markdownIt.render(desc)} `; } return ` `; } } }); 核心逻辑如上，获取到每一块:::demo 代码块 :::里面的代码块，然后分别获取到代码块里面的HTML模板、脚本和样式，他们有两个作用，一是传给我们的自定义组件code-block，在里面我会对代码块做一些样式和功能性的封装；二是组合成codepen的提交参数，codepen是一个在线代码编辑平台，它可以通过表单提交代码然后跳转演示，同样的平台还有jsfiddle和jsbin等。这里面我使用vue-template-compiler去提取模板变量，但是你也可以用别的方式去提取，比如cheerio👇 const cheerio = require('cheerio'); function fetch (str, tag) { var $ = cheerio.load(str, { decodeEntities: false }); if (!tag) return str; return $(tag).html(); } // ... let codepen = { html: fetch(content, 'template'), js: fetch(content, 'script'), css: fetch(content, 'style') }; 因为一份文档里面有多个demo，所以我们需要一个componentCodeList去存储每个代码块，然后最终遍历插入，最终生成下面这个模板并返回 ` ${markdownIt.render(source)} export default { name: 'st-doc', components: { ${componentCodeList.join(',')} } } ${Array.from(styleCodeList, m => m.content).join('\\n')} ` 除了处理demo内的代码块，我们还可以对markdown-it生成的HTML标签做一些处理，它本身提供一些rule允许你对它进行一些操作，比如给table标签替换一个类名👇 markdownIt.renderer.rules.table_open = function() { return ''; }; 同时你也可以通过fence自己定义某些标签的渲染规则，比如如果在模板中用到插值{{ xx }}，因为我们把整个文本返回给vue-loader处理，如果不对双大括号做处理的话，在显示纯文本的代码的时候，双大括号也会变解析成模板，在父组件内就会报错找不到该变量，所以需要写一个函数替换双大括号👇 markdownIt.renderer.rules.fence = genInlineLabel(markdownIt.renderer.rules.fence); function genInlineLabel (render) { return function() { return render.apply(this, arguments) .replace('{{', '{ { ') .replace('}}', ' } }'); }; } CodeBlock组件 从上面看到我们把template，js，css提取出来之后都注入到了CodeBlock这个组件当中，这个组件主要就是做一些样式上的处理同时添加跳转codepen的方法👇 goCodepen() { // https://blog.codepen.io/documentation/api/prefill const { js, html, css } = this.codepen; const resourcesTpl = '' + '\\n'; let jsTpl = (js || '').replace(/export default/, 'var Main =').trim(); let htmlTpl = `${resourcesTpl}\\n\\n${html.trim()}\\n`; jsTpl = jsTpl ? jsTpl + \"\\nvar Ctor = Vue.extend(Main)\\nnew Ctor().$mount('#app')\" : \"new Vue().$mount('#app')\"; let cssTpl = `html { font-size: 100px; } #app{ font-size: 14px; }\\n${css || ''}`; const data = { js: jsTpl, css: cssTpl, html: htmlTpl }; const form = document.getElementById('fiddle-form') || document.createElement('form'); while (form.firstChild) { form.removeChild(form.firstChild); } form.method = 'POST'; form.action = 'https://codepen.io/pen/define/'; form.target = '_blank'; form.style.display = 'none'; const input = document.createElement('input'); input.setAttribute('name', 'data'); input.setAttribute('type', 'hidden'); input.setAttribute('value', JSON.stringify(data)); form.appendChild(input); document.body.appendChild(form); form.submit(); } 这里要注意的是，我们需要给codepen写一段注入的代码，去引用我们当前已发布的最新版本的代码包，因为组件库托管在npm上，所以我这里引用的是unpkg.com上的代码包，只要你的包在npm上发布了，都会被同步到unpkg.com中。最后我们在main.js中全局注册codeBlock组件Vue.component('code-block', codeBlock)，这样子就可以在所有地方引用该组件了 总结 整个流程是两部分：第一部分把Markdown文件转成HTML标签，第二部分提取:::demo 代码块 :::代码块里面的内容传给全局的codeBlock组件，然后把一二部分合成一个组件模板，传给vue-loader去渲染，在官网中我们只需要在路由里面引用Markdown文件就可以了。具体的代码逻辑在build/markdown-loader.js powered by Gitbook该文件修订时间： 2019-09-12 00:10:40 "},"structures/初始化新组件.html":{"url":"structures/初始化新组件.html","title":"初始化新组件","keywords":"","body":"约定优于配置 简单说就是用约定好的规则作为框架来写代码。在steam-game-ui中一个每次要新加一个新的组件要做以下几件事： 往packages文件夹里面添加组件文件、文档和导出组件的index.js 在打包入口引入和导出新组件 往examples文件夹里面添加路由引入组件以及添加导航 往tests文件夹里面添加单元测试文件 它们的配置都是分散的，不熟悉项目结构的人容易忽略其中的某一个步骤，而且分散的配置也容易导致出错，时间一长每次添加组件的时候可能还得先查看一下代码逻辑。所以在steam-game-ui中把部分配置单独提取出来，同时新增npm run new 组件名 [组件中文名]命令初始化新的组件。 创建新文件 一个新的组件需要新建以下文件：packages/组件/组件.vue、packages/组件/index.js、packages/组件/docs/index.md、tests/specs/组件.spec.js，他们的初始化模板都是共性的，我们只需要获取组件的名称和中文名称就可以生成了，这里拿packages/组件/组件.vue举个简单的例子👇 const Files = [{ filename: path.join(`${ComponentName}.vue`), content: ` 新组件 export default { name: 'St${ComponentName}' }; ` }] // 创建 package Files.forEach(file => { fileSave(path.join(PackagePath, file.filename)) .write(file.content, 'utf8') .end('\\n'); }); 我们写了一个Files的模板列表，然后每一个模板需要提供filename模板路径和content模板内容，然后遍历列表用fs生成对应的文件。其他的文件也是一样的，只需要往Files列表里面新增模板就可以了，具体的模板参考build/new.js里面的配置。 自动引入组件 在打包入口的packages/index.js需要引用和导出组件，同时还需要导出一个install方法，在install中除了部分组件有指令或者服务的方式调用，其他的都是注册一下组件就可以了。所以我们可以把所有的组件列成一份组件清单components.json，然后根据这份组件清单和模板去自动生成packages/index.js，因为指令和服务调用的组件有限，所以这部分的调用我们还是写死在模板里面。这块的工作因为就是打包的过程，我放在build\\build-entry.js里面，同时因为需要用到插值，所以这里使用了一个模板引擎，遍历components.json然后渲染模板，最后通过fs去生成文件。 components.json的自动生成过程和上面的生成文件一样 { \"button\": \"packages/button/index.js\", \"icon\": \"packages/icon/index.js\", \"loading\": \"packages/loading/index.js\", \"message\": \"packages/message/index.js\", \"clickoutside\": \"packages/clickoutside/index.js\" } build\\build-entry.js包括一个模板和模板的插值逻辑，然后生成文件，代码如下👇 %accordion%点击查看折叠代码%accordion% var components = require('./../components.json'); var fs = require('fs'); var render = require('json-templater/string'); var uppercamelcase = require('uppercamelcase'); var path = require('path'); var endOfLine = require('os').EOL; var OUTPUT_PATH = path.join(__dirname, './../packages/index.js'); var IMPORT_TEMPLATE = 'import {{name}} from \\'packages/{{package}}/index.js\\';'; var INSTALL_COMPONENT_TEMPLATE = ' {{name}}'; var MAIN_TEMPLATE = `/* Automatically generated by './build/gen-components-index.js' */ {{include}} import 'src/style/icon.scss'; const components = [ {{install}} ]; const install = function (Vue, opts = {}) { components.forEach(component => { Vue.component(component.name, component); }); Vue.use(Loading.directive); Vue.directive('clickoutside', Clickoutside); Vue.prototype.$message = Message; Vue.prototype.$loading = Loading.service; }; if (typeof window !== 'undefined' && window.Vue) { install(window.Vue); } export default { version: '{{version}}', install, {{list}} }; `; var componentNames = Object.keys(components); var includeComponentTemplate = []; var installTemplate = []; var listTemplate = []; componentNames.forEach(name => { let componentName = uppercamelcase(name); includeComponentTemplate.push(render(IMPORT_TEMPLATE, { name: componentName, package: name })); if (['Loading', 'Message', 'Clickoutside'].indexOf(componentName) === -1) { installTemplate.push(render(INSTALL_COMPONENT_TEMPLATE, { name: componentName, component: name })); } if (['Loading', 'Message', 'Clickoutside', 'Icon'].indexOf(componentName) === -1) { listTemplate.push(` ${componentName}`); } }); var template = render(MAIN_TEMPLATE, { include: includeComponentTemplate.join(endOfLine), install: installTemplate.join(',' + endOfLine), version: process.env.VERSION || require('./../package.json').version, list: listTemplate.join(',' + endOfLine) }); fs.writeFileSync(OUTPUT_PATH, template); %/accordion% 配置导航 这一块也单独抽成一个通用配置nav.config.json，这里不仅有组件的导航也有一些公共的文档的导航，所以这里我们单独用一个components字段来维护组件的导航，在new新组件的时候就往components里面push新的组件。在官网里面只需要读取这份json然后添加到导航上就可以了。 { \"guide\": { \"name\": \"开发指南\", \"children\": [{ \"name\": \"快速上手\", \"path\": \"/quickstart\", \"docsPath\": \"examples/guide/quickstart.md\" }, { \"name\": \"参与开发\", \"path\": \"/develop\", \"docsPath\": \"examples/guide/develop.md\" }] }, \"components\": { \"name\": \"组件\", \"children\": [ { \"name\": \"Icon 图标\", \"path\": \"/icon\", \"docsPath\": \"packages/icon/docs/index.md\" }, { \"name\": \"Button 按钮\", \"path\": \"/button\", \"docsPath\": \"packages/button/docs/index.md\" } ] } } 新组件的添加逻辑👇 // 添加到 nav.config.json const navConfigFile = require('./../examples/nav.config.json'); navConfigFile['components'].children.push({ name: componentname !== chineseName ? `${ComponentName} ${chineseName}` : ComponentName, path: `/${componentname}`, docsPath: `packages/${componentname}/docs/index.md` }); fileSave(path.join(__dirname, './../examples/nav.config.json')) .write(JSON.stringify(navConfigFile, null, ' '), 'utf8') .end('\\n'); 配置路由 路由的配置同样也是依据nav.config.json这份配置，因为我们把模块的路径通过变量的方式提取出来了，所以这里还会涉及到一个关于依赖管理的知识点。我们知道webpack是静态编译，当require的路径有表达式的时候，编译阶段无法知道要引入哪些文件。但是webpack会根据表达式的内容区拆分成一个路径和文件名，然后把路径下的文件全部引入，当运行时的时候再去解析表达式，然后去匹配引入的文件。所以webpack能够支持动态地require，但会导致所有可能用到的模块都包含在bundle 中。但是通过require.context可以让我们手动创建一个符合我们自定义规则的引用上下文，这样就能够精准得获取到我们只需要用到的模块。语法如下 require.context(directory, useSubdirectories = false, regExp = /^\\.\\//); 项目内的具体配置如下👇 import Vue from 'vue'; import navConfig from './nav.config'; import Router from 'vue-router'; import Home from './views/Home.vue'; Vue.use(Router); let navs = []; const componentsContext = require.context('./../packages/', true, /\\.md/); const componentsContextKeys = componentsContext.keys(); const guideContext = require.context('./../examples/', true, /\\.md/); const guideContextKeys = guideContext.keys(); Object.keys(navConfig).forEach(group => { navConfig[group].children.forEach(nav => { if (nav.path && nav.docsPath) { let docsPath = nav.docsPath.replace(/examples|packages/, '.'); let isGuide = guideContextKeys.indexOf(docsPath) > -1; let isComponent = componentsContextKeys.indexOf(docsPath) > -1; if (isGuide || isComponent) { navs.push({ path: nav.path, component: isGuide ? guideContext(docsPath).default : componentsContext(docsPath).default }); } } }); }); let router = { mode: 'history', base: process.env.BASE_URL, routes: [ { path: '/', name: 'home', component: Home, children: navs } ] }; export default new Router(router); 总结 经过上面的工作，我们就能够使用npm run new 组件名 [组件中文名]命令来初始化一个新的组件了，具体的代码查看build/new.js powered by Gitbook该文件修订时间： 2019-09-12 00:10:40 "}}